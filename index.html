<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<title>DXF → Serial</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
body { font-family: sans-serif; background: #f4f4f4; margin:0; }
header { background: #0078d7; color: white; padding: 10px; text-align: center; font-size: 18px; }
#controls { background: white; padding: 10px; text-align: center; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
#canvas { display: block; margin: 10px auto; border: 1px solid #ccc; background: white; }
button { margin:5px; padding:10px 15px; border:none; border-radius:8px; background: #0078d7; color:white; font-size:14px; }
button:disabled { background: #aaa; }
#status { display: block; margin: 10px auto; border: 1px solid #ccc; margin-left: 10px; font-weight:bold; }
</style>
</head>
<body>
<header>DXF Viewer + COM Sender (Multi-Select без Ctrl)</header>

<div id="controls">
  <input type="file" id="fileInput" accept=".dxf">
  <button id="connectBtn">Подключить COM-порт</button>
  <button id="disconnectBtn" disabled>Отключить COM-порт</button>
  <button id="sendBtn" disabled>Отправить выбранные контуры</button>
  <span id="status">Порт: ❌ Не подключен</span>
</div>

<canvas id="canvas" width="400" height="500"></canvas>

<script src="https://cdn.jsdelivr.net/npm/dxf-parser@1.1.2/dist/dxf-parser.js"></script>

<script>
const fileInput = document.getElementById("fileInput");
const connectBtn = document.getElementById("connectBtn");
const disconnectBtn = document.getElementById("disconnectBtn");
const sendBtn = document.getElementById("sendBtn");
const statusEl = document.getElementById("status");
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

let contours = [];
let selectedSet = new Set();
let port = null;
let writer = null;
let scale = 1, offsetX = 0, offsetY = 0;

// ---------------- Web Serial ----------------
async function updateStatus() {
  statusEl.textContent = port && writer ? "Порт: ✅ Подключен" : "Порт: ❌ Не подключен";
  disconnectBtn.disabled = !port;
  connectBtn.disabled = !!port;
}

connectBtn.addEventListener("click", async () => {
  try {
    port = await navigator.serial.requestPort();
    await port.open({ baudRate: 115200 });
    writer = port.writable.getWriter();
    await updateStatus();
    alert("COM-порт подключён!");
  } catch (err) {
    alert("Ошибка подключения: " + err);
  }
});

disconnectBtn.addEventListener("click", async () => {
  if (writer) {
    writer.releaseLock();
    writer = null;
  }
  if (port) {
    await port.close();
    port = null;
  }
  await updateStatus();
  alert("COM-порт отключён!");
});

async function sendData(data) {
  if (!writer) return alert("Порт не подключен!");
  try {
    await writer.write(new TextEncoder().encode(data + "\n"));
  } catch (err) {
    alert("Ошибка записи: " + err);
  }
}

// ---------------- DXF Загрузка ----------------
fileInput.addEventListener("change", async e => {
  const file = e.target.files[0];
  if (!file) return;
  const text = await file.text();

  const parser = new window.DxfParser();
  let dxf;
  try { dxf = parser.parseSync(text); }
  catch (err) { alert("Ошибка чтения DXF: " + err.message); return; }

  contours = dxf.entities.filter(ent =>
    ["LWPOLYLINE","POLYLINE","LINE","CIRCLE","ARC","SPLINE","ELLIPSE"].includes(ent.type)
  );

  if(contours.length===0){ alert("Нет поддерживаемых контуров"); return; }

  computeBounds();
  selectedSet.clear();
  drawContours();
  sendBtn.disabled = true;
});

// ---------------- Отрисовка ----------------
function computeBounds(){
  const xs=[], ys=[];
  contours.forEach(c=>{
    if(c.vertices) c.vertices.forEach(v=>{xs.push(v.x); ys.push(v.y);});
    if(c.controlPoints) c.controlPoints.forEach(v=>{xs.push(v.x); ys.push(v.y);});
    if(c.center) { xs.push(c.center.x); ys.push(c.center.y);}
  });
  const minX=Math.min(...xs), maxX=Math.max(...xs);
  const minY=Math.min(...ys), maxY=Math.max(...ys);
  const dx=maxX-minX, dy=maxY-minY;
  const margin=20;
  scale=Math.min((canvas.width-margin*2)/dx,(canvas.height-margin*2)/dy);
  offsetX=(canvas.width-dx*scale)/2 - minX*scale;
  offsetY=(canvas.height+dy*scale)/2 + minY*scale;
}

function drawContours(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  contours.forEach((c,i)=>{
    ctx.beginPath();
    ctx.strokeStyle = selectedSet.has(i) ? "red" : "#000";
    switch(c.type){
      case "LWPOLYLINE":
      case "POLYLINE":
        c.vertices.forEach((v,j)=>{
          const x=v.x*scale+offsetX;
          const y=canvas.height-(v.y*scale+offsetY);
          if(j===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
        });
        if(c.shape) ctx.closePath();
        break;
      case "LINE":
        const [p1,p2]=c.vertices;
        ctx.moveTo(p1.x*scale+offsetX, canvas.height-(p1.y*scale+offsetY));
        ctx.lineTo(p2.x*scale+offsetX, canvas.height-(p2.y*scale+offsetY));
        break;
      case "CIRCLE":
        ctx.arc(c.center.x*scale+offsetX, canvas.height-(c.center.y*scale+offsetY),
                c.radius*scale,0,2*Math.PI);
        break;
      case "SPLINE":
        const pts=c.controlPoints||[];
        if(pts.length){
          ctx.moveTo(pts[0].x*scale+offsetX, canvas.height-(pts[0].y*scale+offsetY));
          for(let i=1;i<pts.length;i++){
            const p=pts[i];
            ctx.lineTo(p.x*scale+offsetX, canvas.height-(p.y*scale+offsetY));
          }
        }
        break;
      case "ELLIPSE":
        if(c.majorAxisEndPoint && c.center){
          const rx=Math.abs(c.majorAxisEndPoint.x)*scale;
          const ry=Math.abs(c.majorAxisEndPoint.y)*scale;
          ctx.save();
          ctx.translate(c.center.x*scale+offsetX, canvas.height-(c.center.y*scale+offsetY));
          ctx.scale(1, ry/rx);
          ctx.arc(0,0,rx,0,2*Math.PI);
          ctx.restore();
        }
        break;
    }
    ctx.stroke();
  });
}

// ---------------- Выделение без Ctrl ----------------
canvas.addEventListener("click", e=>{
  const rect=canvas.getBoundingClientRect();
  const x=e.clientX-rect.left;
  const y=e.clientY-rect.top;

  let nearest=-1, minDist=1e9;
  contours.forEach((c,i)=>{
    let pts=[];
    if(c.vertices) pts=c.vertices;
    if(c.controlPoints) pts=c.controlPoints;
    pts.forEach(v=>{
      const vx=v.x*scale+offsetX;
      const vy=canvas.height-(v.y*scale+offsetY);
      const d=Math.hypot(vx-x, vy-y);
      if(d<minDist){ minDist=d; nearest=i; }
    });
  });

  if(nearest!==-1 && minDist<50){
    // инвертируем выделение
    if (selectedSet.has(nearest)) selectedSet.delete(nearest);
    else selectedSet.add(nearest);

    drawContours();
    sendBtn.disabled = selectedSet.size === 0;
  }
});

// ---------------- Экспорт нескольких контуров ----------------
function exportSelectedToDXF() {
  let dxf = "0\nSECTION\n2\nHEADER\n9\n$ACADVER\n1\nAC1015\n0\nENDSEC\n";
  dxf += "0\nSECTION\n2\nENTITIES\n";
  for (let idx of selectedSet) {
    dxf += exportContourEntity(contours[idx]);
  }
  dxf += "0\nENDSEC\n0\nEOF\n";
  return dxf;
}

function exportContourEntity(c) {
  let s = "";
  const verts = c.vertices || c.points || c.vertexes || c.controlPoints || [];

  if ((["LWPOLYLINE", "POLYLINE"].includes(c.type)) && verts.length) {
    s += "0\nLWPOLYLINE\n8\n0\n";
    s += `90\n${verts.length}\n70\n${c.closed || c.shape ? 1 : 0}\n`;
    verts.forEach(v => { s += `10\n${v.x}\n20\n${v.y}\n`; });
  }
  else if (c.type === "LINE" && verts.length >= 2) {
    const [p1,p2]=verts;
    s += "0\nLINE\n8\n0\n";
    s += `10\n${p1.x}\n20\n${p1.y}\n11\n${p2.x}\n21\n${p2.y}\n`;
  }
  else if (c.type === "CIRCLE") {
    s += "0\nCIRCLE\n8\n0\n";
    s += `10\n${c.center.x}\n20\n${c.center.y}\n40\n${c.radius}\n`;
  }
  else if (c.type === "ARC") {
    s += "0\nARC\n8\n0\n";
    s += `10\n${c.center.x}\n20\n${c.center.y}\n40\n${c.radius}\n`;
    s += `50\n${c.startAngle||0}\n51\n${c.endAngle||0}\n`;
  }
  else if (c.type === "ELLIPSE" && c.center && c.majorAxisEndPoint) {
    s += "0\nELLIPSE\n8\n0\n";
    s += `10\n${c.center.x}\n20\n${c.center.y}\n30\n0\n`;
    s += `11\n${c.majorAxisEndPoint.x}\n21\n${c.majorAxisEndPoint.y}\n31\n0\n`;
    s += `40\n${c.axisRatio || 1}\n`;
  }
  else if (c.type === "SPLINE" && c.controlPoints?.length) {
    s += "0\nSPLINE\n8\n0\n70\n8\n";
    s += `73\n${c.controlPoints.length}\n`;
    for (let p of c.controlPoints) s += `10\n${p.x}\n20\n${p.y}\n30\n${p.z||0}\n`;
  }

  return s;
}

// ---------------- Отправка через COM ----------------
sendBtn.addEventListener("click", async ()=>{
  if (!writer) return alert("COM-порт не подключён!");
  if (selectedSet.size === 0) return alert("Выберите хотя бы один контур!");
  const dxfText = exportSelectedToDXF();
  await sendData(dxfText);
  alert(`Отправлено ${selectedSet.size} контур(ов) через COM-порт!`);
});
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<title>DXF → Serial</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
body { font-family: sans-serif; background: #f4f4f4; margin:0; }
header { background: #0078d7; color: white; padding: 10px; text-align: center; font-size: 18px; }
#controls { background: white; padding: 10px; text-align: center; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
#canvas { display: block; margin: 10px auto; border: 1px solid #ccc; background: white; }
button { margin:5px; padding:10px 15px; border:none; border-radius:8px; background: #0078d7; color:white; font-size:14px; }
button:disabled { background: #aaa; }
#status { display: block; margin: 10px auto; border: 1px solid #ccc; margin-left: 10px; font-weight:bold; }
</style>
</head>
<body>
<header>DXF Viewer + COM Sender</header>

<div id="controls">
<input type="file" id="fileInput" accept=".dxf">
<button id="connectBtn">Подключить COM-порт</button>
<button id="disconnectBtn" disabled>Отключить COM-порт</button>
<button id="sendBtn" disabled>Отправить выбранный контур</button>
<span id="status">Порт: ❌ Не подключен</span>
</div>

<canvas id="canvas" width="400" height="500"></canvas>

<!-- DXF Parser -->
<script src="https://cdn.jsdelivr.net/npm/dxf-parser@1.1.2/dist/dxf-parser.js"></script>

<script>
const fileInput = document.getElementById("fileInput");
const connectBtn = document.getElementById("connectBtn");
const disconnectBtn = document.getElementById("disconnectBtn");
const sendBtn = document.getElementById("sendBtn");
const statusEl = document.getElementById("status");
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

let contours = [];
let selected = null;
let port = null;
let writer = null;
let scale = 1, offsetX = 0, offsetY = 0;

// ---------------- Web Serial ----------------
async function updateStatus() {
  statusEl.textContent = port && writer ? "Порт: ✅ Подключен" : "Порт: ❌ Не подключен";
  disconnectBtn.disabled = !port;
  connectBtn.disabled = !!port;
}

connectBtn.addEventListener("click", async () => {
  try {
    port = await navigator.serial.requestPort();
    await port.open({ baudRate: 115200 });

    // Создаём writer один раз
    writer = port.writable.getWriter();

    await updateStatus();
    alert("COM-порт подключён!");
  } catch (err) {
    alert("Ошибка подключения: " + err);
  }
});

disconnectBtn.addEventListener("click", async () => {
  if (writer) {
    writer.releaseLock();
    writer = null;
  }
  if (port) {
    await port.close();
    port = null;
  }
  await updateStatus();
  alert("COM-порт отключён!");
});

// Отправка данных через writer
async function sendData(data) {
  if (!writer) return alert("Порт не подключен!");
  try {
    await writer.write(new TextEncoder().encode(data + "\n"));
  } catch (err) {
    alert("Ошибка записи: " + err);
  }
}

// ---------------- DXF Загрузка ----------------
fileInput.addEventListener("change", async e => {
  const file = e.target.files[0];
  if (!file) return;
  const text = await file.text();

  const parser = new window.DxfParser();
  let dxf;
  try { dxf = parser.parseSync(text); } 
  catch (err) { alert("Ошибка чтения DXF: " + err.message); return; }

  contours = dxf.entities.filter(ent =>
    ["LWPOLYLINE","POLYLINE","LINE","CIRCLE","ARC","SPLINE","ELLIPSE"].includes(ent.type)
  );

  if(contours.length===0){ alert("Нет поддерживаемых контуров"); return; }

  computeBounds();
  drawContours();
  sendBtn.disabled=true;
  selected=null;
});

// ---------------- Отрисовка ----------------
function computeBounds(){
  const xs=[], ys=[];
  contours.forEach(c=>{
    if(c.vertices) c.vertices.forEach(v=>{xs.push(v.x); ys.push(v.y);});
    if(c.controlPoints) c.controlPoints.forEach(v=>{xs.push(v.x); ys.push(v.y);});
    if(c.center) { xs.push(c.center.x); ys.push(c.center.y);}
  });
  const minX=Math.min(...xs), maxX=Math.max(...xs);
  const minY=Math.min(...ys), maxY=Math.max(...ys);
  const dx=maxX-minX, dy=maxY-minY;
  const margin=20;
  scale=Math.min((canvas.width-margin*2)/dx,(canvas.height-margin*2)/dy);
  offsetX=(canvas.width-dx*scale)/2 - minX*scale;
  offsetY=(canvas.height+dy*scale)/2 + minY*scale;
}

function drawContours(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  contours.forEach((c,i)=>{
    ctx.beginPath();
    ctx.strokeStyle=(i===selected)?"red":"#000";
    switch(c.type){
      case "LWPOLYLINE":
      case "POLYLINE":
        c.vertices.forEach((v,j)=>{
          const x=v.x*scale+offsetX;
          const y=canvas.height-(v.y*scale+offsetY);
          if(j===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
        });
        if(c.shape) ctx.closePath();
        break;
      case "LINE":
        const [p1,p2]=c.vertices;
        ctx.moveTo(p1.x*scale+offsetX, canvas.height-(p1.y*scale+offsetY));
        ctx.lineTo(p2.x*scale+offsetX, canvas.height-(p2.y*scale+offsetY));
        break;
      case "CIRCLE":
        ctx.arc(c.center.x*scale+offsetX, canvas.height-(c.center.y*scale+offsetY),
                c.radius*scale,0,2*Math.PI);
        break;
      case "SPLINE":
        const pts=c.controlPoints||[];
        if(pts.length){
          ctx.moveTo(pts[0].x*scale+offsetX, canvas.height-(pts[0].y*scale+offsetY));
          for(let i=1;i<pts.length;i++){
            const p=pts[i];
            ctx.lineTo(p.x*scale+offsetX, canvas.height-(p.y*scale+offsetY));
          }
        }
        break;
      case "ELLIPSE":
        if(c.majorAxisEndPoint && c.center){
          const rx=Math.abs(c.majorAxisEndPoint.x)*scale;
          const ry=Math.abs(c.majorAxisEndPoint.y)*scale;
          ctx.save();
          ctx.translate(c.center.x*scale+offsetX, canvas.height-(c.center.y*scale+offsetY));
          ctx.scale(1, ry/rx);
          ctx.arc(0,0,rx,0,2*Math.PI);
          ctx.restore();
        }
        break;
    }
    ctx.stroke();
  });
}

// ---------------- Выбор контура ----------------
canvas.addEventListener("click", e=>{
  const rect=canvas.getBoundingClientRect();
  const x=e.clientX-rect.left;
  const y=e.clientY-rect.top;

  let nearest=-1, minDist=1e9;
  contours.forEach((c,i)=>{
    let pts=[];
    if(c.vertices) pts=c.vertices;
    if(c.controlPoints) pts=c.controlPoints;
    pts.forEach(v=>{
      const vx=v.x*scale+offsetX;
      const vy=canvas.height-(v.y*scale+offsetY);
      const d=Math.hypot(vx-x, vy-y);
      if(d<minDist){ minDist=d; nearest=i; }
    });
  });

  if(nearest!==-1 && minDist<50){
    selected=nearest;
    drawContours();
    sendBtn.disabled=false;
  }
});

// ---------------- Экспорт DXF ----------------
function exportContourToDXF(c) {
  let dxf = "";

  // --- HEADER ---
  dxf += "0\nSECTION\n2\nHEADER\n";
  dxf += "9\n$ACADVER\n1\nAC1015\n"; // версия DXF 2000
  dxf += "0\nENDSEC\n";

  // --- ENTITIES ---
  dxf += "0\nSECTION\n2\nENTITIES\n";

  const verts = c.vertices || c.points || c.vertexes || c.controlPoints || [];

  // --- POLYLINE / POLYGON / LWPOLYLINE ---
  if ((["LWPOLYLINE", "POLYLINE", "POLYGON"].includes(c.type)) && verts.length) {
    dxf += "0\nLWPOLYLINE\n8\n0\n";
    dxf += `90\n${verts.length}\n`;
    dxf += `70\n${c.closed || c.shape ? 1 : 0}\n`;
    verts.forEach(v => {
      dxf += `10\n${v.x}\n20\n${v.y}\n`;
    });

  // --- LINE ---
  } else if (c.type === "LINE" && verts.length >= 2) {
    const [p1, p2] = verts;
    dxf += "0\nLINE\n8\n0\n";
    dxf += `10\n${p1.x}\n20\n${p1.y}\n`;
    dxf += `11\n${p2.x}\n21\n${p2.y}\n`;

  // --- CIRCLE ---
  } else if (c.type === "CIRCLE" && c.center && c.radius !== undefined) {
    dxf += "0\nCIRCLE\n8\n0\n";
    dxf += `10\n${c.center.x}\n20\n${c.center.y}\n`;
    dxf += `40\n${c.radius}\n`;

  // --- ARC ---
  } else if (c.type === "ARC" && c.center && c.radius !== undefined) {
    dxf += "0\nARC\n8\n0\n";
    dxf += `10\n${c.center.x}\n20\n${c.center.y}\n`;
    dxf += `40\n${c.radius}\n`;
    dxf += `50\n${c.startAngle || 0}\n51\n${c.endAngle || 0}\n`;

  // --- ELLIPSE ---
  } else if (c.type === "ELLIPSE" && c.center && c.majorAxisEndPoint) {
    dxf += "0\nELLIPSE\n8\n0\n";
    dxf += `10\n${c.center.x}\n20\n${c.center.y}\n30\n${c.center.z || 0}\n`;
    dxf += `11\n${c.majorAxisEndPoint.x}\n21\n${c.majorAxisEndPoint.y}\n31\n${c.majorAxisEndPoint.z || 0}\n`;
    dxf += `40\n${c.axisRatio || 1}\n`;

  // --- SPLINE ---
  } else if (c.type === "SPLINE" && c.controlPoints?.length) {
    dxf += "0\nSPLINE\n8\n0\n";
    dxf += "70\n8\n"; // NURBS флаг
    dxf += `71\n${c.degreeOfSplineCurve || 3}\n`;
    dxf += `72\n${(c.knotValues?.length) || 0}\n`;
    dxf += `73\n${c.controlPoints.length}\n`;
    dxf += `74\n${c.numberOfFitPoints || 0}\n`;

    // Узлы
    if (c.knotValues) {
      for (let k of c.knotValues) dxf += `40\n${k}\n`;
    }

    // Контрольные точки
    for (let p of c.controlPoints) {
      dxf += `10\n${p.x}\n20\n${p.y}\n30\n${p.z || 0}\n`;
    }

  // --- 3DFACE (редкий случай) ---
  } else if (c.type === "3DFACE" && verts.length >= 3) {
    dxf += "0\n3DFACE\n8\n0\n";
    verts.forEach((v, i) => {
      dxf += `10${i}\n${v.x}\n20${i}\n${v.y}\n30${i}\n${v.z || 0}\n`;
    });

  // --- FALLBACK ---
  } else {
    console.warn("❗ Неизвестный или пустой контур:", c.type, c);
  }

  // --- END ---
  dxf += "0\nENDSEC\n0\nEOF\n";
  return dxf;
}

// ---------------- Отправка через COM ----------------
sendBtn.addEventListener("click", async ()=>{
  if(!writer) return alert("COM-порт не подключён!");
  if(selected===null) return alert("Выберите контур!");
  console.log("=== Дамп выбранного объекта ===");
  console.log(JSON.stringify(contours[selected], null, 2));
  const dxfText = exportContourToDXF(contours[selected]);
  await sendData(dxfText);
  alert("Контур отправлен через COM-порт!");
});
</script>
</body>
</html>
